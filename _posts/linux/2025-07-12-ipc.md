---
layout: post
title: "Inter-Process Communication in Linux"
date: 2025-07-14 10:00:00 +0700
categories: [Linux]
tags: [linux, ipc, sockets, shared-memory, message-queues, signals, c-programming]
excerpt: "A practical guide to Linux IPC mechanisms — sockets, message queues, shared memory, and signals — with API references and design guidance."
---

Processes in a Linux system are isolated by design: each has its own virtual address space and cannot directly access another's memory. Inter-Process Communication (IPC) is the set of mechanisms the OS provides to let processes exchange data and coordinate with each other despite this isolation.

This post covers the main IPC techniques available on Linux, how each works, and when to use one over another.

## IPC Techniques at a Glance

| Mechanism | Best For | Direction |
|-----------|----------|-----------|
| Unix Domain Sockets | Structured, bidirectional IPC on the same host | Bidirectional |
| Network Sockets | Communication across machines | Bidirectional |
| Message Queues | Asynchronous, prioritized message passing | N senders → 1 receiver |
| Shared Memory | High-throughput data sharing (publisher/subscriber) | Shared read/write |
| Signals | Lightweight notifications and remote commands | One-way |
| Pipes | Simple, sequential data flow | One-way |

The relationship between user-space processes and the rest of the system looks like this:

```
User Space Processes
      ⇕
Netlink Sockets / IOCTLs / Device Files / System Calls
      ⇕
   Kernel
      ⇕
  Device Drivers
      ⇕
   Hardware
```

![IPC overview](/assets/img/linux/ipc.png)

---

## Sockets

The socket API provides a unified interface for communication between processes — whether they're on the same machine or across a network.

**Unix Domain Sockets** — IPC between processes on the same host. Data never leaves the machine; communication happens through the kernel using a filesystem path as the address.

**Network Sockets** — Communication between processes on different machines, over TCP/IP or UDP.

### Connection-Oriented Communication: Server Lifecycle

The server side of a socket-based system follows a well-defined state machine:

1. **Create a master socket** — `M = socket()`. This is the "mother socket" from which all client connections are born.
2. **Bind** — Associate the socket with an address (a file path for Unix domain sockets, or an IP/port for network sockets).
3. **Listen** — Mark the socket as passive, ready to accept connections.
4. **Accept** — When a client connects, `accept()` creates a new *client handle* (a communication file descriptor, or data socket) specific to that client. All actual data exchange happens through this handle, not through `M`.
5. **Communicate** — Use `recvfrom()` / `sendto()` (or `recv()` / `send()`) on the client handle.
6. **Close** — Close the data socket when the client disconnects; close and remove the master socket on shutdown.

The master socket `M` is only used to accept new connections. The server maintains a list of all active client handles for ongoing communication.

### Message Types

Messages between client and server typically fall into two categories:

- **Connection Initiation Request (CIR)** — The initial handshake sent by a client to establish a session.
- **Service Request Message (SRM)** — Application-level messages exchanged after the connection is established.

### Unix Domain Socket Types

| Type | Use Case |
|------|----------|
| `SOCK_STREAM` | Continuous byte stream; suited for large file transfers or persistent sessions |
| `SOCK_DGRAM` | Discrete messages; suited for small, bounded data exchanges between local processes |

### Multiplexing with `select()`

Without multiplexing, a server can only handle one client at a time — it blocks waiting for data from a single socket. The `select()` system call solves this by allowing the server to monitor a *set* of file descriptors simultaneously and act only on those that are ready.

```c
fd_set read_fds;
FD_ZERO(&read_fds);
FD_SET(master_socket, &read_fds);
// add all client handles to read_fds...

select(max_fd + 1, &read_fds, NULL, NULL, NULL);

if (FD_ISSET(master_socket, &read_fds)) {
    // new connection incoming — call accept()
}
// check each client handle with FD_ISSET()...
```

Linux also provides `poll()` and `epoll()` as more scalable alternatives to `select()` for servers handling large numbers of connections.

![select() multiplexing](/assets/img/linux/select.png)

---

## Message Queues

Message queues are a kernel-managed IPC mechanism for asynchronous, prioritized message passing between processes on the same machine.

Key properties:
- Each queue is identified by a unique name (e.g., `/server-msg-q`)
- Messages have a priority; higher-priority messages are dequeued first
- The queue persists as a kernel resource until explicitly destroyed
- Supports **N senders, 1 receiver** per queue; a receiver can multiplex across multiple queues using `select()`

![Message queue diagram](/assets/img/linux/msgQueue.jpeg)

### API Reference

#### Opening / Creating a Queue

```c
#include <mqueue.h>

mqd_t mq_open(const char *name, int oflag);
mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);
```

| Parameter | Description |
|-----------|-------------|
| `name` | Queue name, must start with `/` (e.g., `"/my-queue"`) |
| `oflag` | Flags: `O_CREAT`, `O_RDONLY`, `O_WRONLY`, `O_RDWR`, `O_NONBLOCK` |
| `mode` | Permissions on the queue (e.g., `0660`) |
| `attr` | Optional attributes: max messages (`mq_maxmsg`), max message size (`mq_msgsize`) |

System limits for these attributes are in `/proc/sys/fs/mqueue/msg_max` and `/proc/sys/fs/mqueue/msgsize_max`.

On success, returns a message queue descriptor (`mqd_t`); `-1` on failure.

#### Sending a Message

```c
int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio);
```

Messages are queued in **decreasing priority order**, with older messages of equal priority ahead of newer ones. If the queue is full and `O_NONBLOCK` is not set, `mq_send()` blocks; otherwise it returns immediately with `errno = EAGAIN`.

#### Receiving a Message

```c
ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio);
```

Dequeues the **oldest message of the highest priority**. Blocks if the queue is empty (unless `O_NONBLOCK` is set). Returns the number of bytes received on success.

#### Closing a Queue

```c
int mq_close(mqd_t mqdes);
```

Closes the descriptor but does not destroy the queue. The kernel maintains a reference count across all processes that have called `mq_open()`; the queue is destroyed only when all have closed it.

#### Destroying a Queue

```c
int mq_unlink(const char *name);
```

Marks the queue for destruction. The actual removal is deferred until all processes with the queue open have called `mq_close()`. Returns `0` on success, `-1` on failure.

### When to Use Message Queues

Message queues are well-suited for task dispatch and event notification between unrelated processes. Because message delivery is asynchronous and the kernel handles queuing, the sender never needs to wait for the receiver to be ready.

---

## Shared Memory

Shared memory is the fastest IPC mechanism because data is never copied — multiple processes map the same physical memory pages into their respective virtual address spaces and access it directly.

### How It Works

Each process has its own virtual address space (VAS), and ordinarily a process can never access memory outside it. Shared memory works by having the kernel map the same physical pages into two different processes' VAS. A write from process A is immediately visible to process B, with no data transfer through the kernel.

![Shared memory diagram](/assets/img/linux/sharedMemory.png)

### The `mmap()` System Call

```c
#include <sys/mman.h>

void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

| Parameter | Description |
|-----------|-------------|
| `addr` | Suggested start address; pass `NULL` to let the kernel choose (recommended) |
| `length` | Size of the mapping in bytes |
| `prot` | Protection flags: `PROT_READ`, `PROT_WRITE`, `PROT_EXEC`, `PROT_NONE` |
| `flags` | `MAP_SHARED` (changes visible to other mappings), `MAP_PRIVATE` (copy-on-write), `MAP_ANONYMOUS` (not backed by a file) |
| `fd` | File descriptor for file-backed mappings; `-1` for anonymous |
| `offset` | Offset in the file; must be page-aligned (`sysconf(_SC_PAGE_SIZE)`) |

After `mmap()` returns, the file descriptor can be closed without affecting the mapping. Returns `MAP_FAILED` on error.

### Design Constraints

Shared memory works best under a **publisher/subscriber** model:

- **One publisher** writes to the shared region; **multiple subscribers** read from it.
- If multiple processes need to write concurrently, you must use mutual exclusion (mutexes, semaphores) to prevent write-write conflicts — at the cost of some performance.

A critical practical consideration: **subscribers don't automatically know when the shared memory has been updated.** The typical pattern is:

1. Publisher writes to shared memory.
2. Publisher sends a notification (via Unix domain socket or message queue) informing subscribers that the data has changed.
3. Subscribers read the updated data on receiving the notification.

This separates the high-throughput data path (shared memory) from the low-frequency signaling path (sockets or message queues).

---

## Signals

Signals are the lightest-weight IPC mechanism. They're not used to transfer data — they're used to send a notification or command to a process asynchronously.

When a process receives a signal, one of three things happens:

1. **Default action** — the kernel performs the default behavior (e.g., terminating the process for `SIGKILL`)
2. **Custom handler** — a signal handler function registered by the process is invoked
3. **Ignored** — the signal is discarded (not all signals can be ignored)

Signal handlers are invoked asynchronously, interrupting the normal execution flow of the process at the highest priority.

```c
#include <signal.h>

void handler(int signum) {
    // handle signal
}

signal(SIGUSR1, handler);   // register handler
// or, more robustly:
struct sigaction sa = { .sa_handler = handler };
sigaction(SIGUSR1, &sa, NULL);
```

![Signal handling](/assets/img/linux/signal.png)

### Common Signals

| Signal | Trigger | Catchable? |
|--------|---------|------------|
| `SIGINT` | Ctrl-C from terminal | Yes |
| `SIGTERM` | `kill <pid>` (default) | Yes |
| `SIGKILL` | `kill -9 <pid>` | **No** — cannot be caught or ignored |
| `SIGABRT` | `abort()` called by process | No |
| `SIGSEGV` | Illegal memory access (segfault) | Yes (but process is usually unrecoverable) |
| `SIGUSR1` / `SIGUSR2` | User-defined; application-controlled | Yes |
| `SIGCHLD` | Child process terminated | Yes — parent should call `wait()` |

### Generating Signals

```c
raise(SIGUSR1);             // process sends signal to itself
kill(target_pid, SIGUSR1);  // process sends signal to another process
// kernel sends signals like SIGKILL, SIGSEGV, SIGCHLD automatically
```

### Limitations

Signals are inherently limited as an IPC mechanism: they carry no payload beyond the signal number, their delivery is asynchronous and can interrupt sensitive operations, and only a small set of functions are safe to call inside a signal handler (async-signal-safe functions). For anything beyond simple notifications, prefer sockets or message queues.

---

## Choosing the Right Mechanism

Each IPC mechanism occupies a different point in the tradeoff space:

**Use Unix Domain Sockets** when you need reliable, bidirectional communication with connection state — they're the most flexible local IPC mechanism and support multiplexing natively.

**Use Message Queues** when producers and consumers operate at different rates and you want the kernel to buffer messages. The built-in priority ordering is a bonus for task dispatch systems.

**Use Shared Memory** when throughput is critical and you're moving large amounts of data. Pair it with a lightweight notification mechanism (sockets or signals) to let readers know when new data is available.

**Use Signals** for lightweight, asynchronous notifications only — not for data transfer.

---

## References

1. *Linux Inter Process Communication (IPC) from Scratch in C* — [Course material](https://github.com/ducndc/linux-system-programming)
2. `man 7 unix`, `man 7 mq_overview`, `man 2 mmap`, `man 7 signal` — Linux man pages