---
layout: post
title: "Linux Netfilter: Kernel Hooks for Packet Processing"
date: 2025-10-18 10:00:00 +0700
categories: [Linux]
tags: [linux, netfilter, kernel, networking, packet-filtering, iptables, kernel-module]
excerpt: "A deep dive into the Linux Netfilter framework — how hooks work, how to register them, and how to write a kernel module that inspects live network traffic."
---

Netfilter is the packet processing framework built into the Linux kernel. It underpins tools like `iptables`, `nftables`, and `conntrack`, and it's what you interact with whenever you write firewall rules or configure NAT. This post explains how Netfilter works at the kernel level and walks through writing a kernel module that hooks into the packet path.

## Overview

Netfilter provides a set of hooks at strategic points in the kernel's networking stack. Kernel modules can register callback functions at these hooks to inspect, modify, drop, or accept packets as they flow through the system.

![Netfilter components](/assets/img/linux/Netfilter-components.svg)

The flow of a network packet through the Netfilter hooks looks like this:

![Netfilter packet flow](/assets/img/linux/Netfilter-packet-flow.svg)

---

## Hook Points

Five hook points are defined for IPv4/IPv6 traffic, corresponding to stages in the routing decision process:

```c
enum nf_inet_hooks {
    NF_INET_PRE_ROUTING,   // 0
    NF_INET_LOCAL_IN,      // 1
    NF_INET_FORWARD,       // 2
    NF_INET_LOCAL_OUT,     // 3
    NF_INET_POST_ROUTING,  // 4
    NF_INET_NUMHOOKS
};
```

| Hook | Kernel Function | Description |
|------|----------------|-------------|
| `NF_INET_PRE_ROUTING` | `ip_rcv()` | All incoming packets, before routing decisions are made |
| `NF_INET_LOCAL_IN` | `ip_local_deliver()` | Incoming packets destined for the local machine |
| `NF_INET_FORWARD` | `ip_forward()` | Incoming packets being forwarded to another interface |
| `NF_INET_LOCAL_OUT` | `ip_build_and_send_pkt()` | Packets generated by local processes before routing |
| `NF_INET_POST_ROUTING` | `ip_finish_output()` | All outgoing packets, just before they hit the wire |

---

## Registering a Hook

### The `nf_hook_ops` Structure

Each hook is described by an `nf_hook_ops` struct:

```c
struct nf_hook_ops {
    struct list_head list;

    /* Fields set by the registering module: */
    nf_hookfn       *hook;      // the callback function
    struct module   *owner;     // THIS_MODULE
    u_int8_t         pf;        // protocol family (e.g., NFPROTO_IPV4)
    unsigned int     hooknum;   // which hook point (e.g., NF_INET_LOCAL_IN)
    int              priority;  // lower = runs earlier
};
```

### Registration API

```c
// Register a single hook
int  nf_register_hook(struct nf_hook_ops *reg);
void nf_unregister_hook(struct nf_hook_ops *reg);

// Register an array of hooks at once
int  nf_register_hooks(struct nf_hook_ops *reg, unsigned int n);
void nf_unregister_hooks(struct nf_hook_ops *reg, unsigned int n);
```

### Protocol Family (`pf`)

The `pf` field selects which protocol family the hook applies to:

```c
enum {
    NFPROTO_UNSPEC =  0,
    NFPROTO_IPV4   =  2,   // IPv4
    NFPROTO_ARP    =  3,   // ARP
    NFPROTO_BRIDGE =  7,   // Ethernet bridging
    NFPROTO_IPV6   = 10,   // IPv6
    NFPROTO_DECNET = 12,
};
```

### Hook Priority

When multiple hooks are registered at the same hook point, they run in ascending priority order (lower number = higher priority, runs first). The predefined priorities for IPv4 are:

```c
enum nf_ip_hook_priorities {
    NF_IP_PRI_FIRST             = INT_MIN,
    NF_IP_PRI_CONNTRACK_DEFRAG  = -400,
    NF_IP_PRI_RAW               = -300,
    NF_IP_PRI_SELINUX_FIRST     = -225,
    NF_IP_PRI_CONNTRACK         = -200,
    NF_IP_PRI_MANGLE            = -150,
    NF_IP_PRI_NAT_DST           = -100,
    NF_IP_PRI_FILTER            =    0,   // iptables filter table
    NF_IP_PRI_SECURITY          =   50,
    NF_IP_PRI_NAT_SRC           =  100,
    NF_IP_PRI_SELINUX_LAST      =  225,
    NF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX,
    NF_IP_PRI_LAST              = INT_MAX,
};
```

Use `NF_IP_PRI_FIRST` to run before everything else, or place your hook relative to the predefined stages (e.g., before or after NAT, before or after connection tracking).

---

## The Hook Callback

The hook function signature is:

```c
typedef unsigned int nf_hookfn(
    unsigned int hooknum,
    struct sk_buff *skb,          // the packet
    const struct net_device *in,  // incoming interface (or NULL)
    const struct net_device *out, // outgoing interface (or NULL)
    int (*okfn)(struct sk_buff *) // call this to continue processing
);
```

The callback must return one of the following verdicts:

| Return Value | Meaning |
|-------------|---------|
| `NF_ACCEPT` (1) | Allow the packet to continue through the stack |
| `NF_DROP` (0) | Discard the packet silently |
| `NF_STOLEN` (2) | The hook takes ownership of the packet; the stack stops processing it |
| `NF_QUEUE` (3) | Queue the packet for userspace processing (via `libnetfilter_queue`) |
| `NF_REPEAT` (4) | Re-invoke this hook on the same packet |
| `NF_STOP` (5) | Accept the packet and skip any remaining hooks at this hook point |

---

## Example: Logging Packet Headers

The following kernel module registers a hook at `NF_INET_LOCAL_IN` and logs the source/destination MAC and IP addresses of every incoming packet.

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/skbuff.h>
#include <linux/ip.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Netfilter hook example: log incoming packet headers");

/* Helper: print an IPv4 address stored in network byte order */
#define NIPQUAD(addr) \
    ((unsigned char *)&addr)[0], \
    ((unsigned char *)&addr)[1], \
    ((unsigned char *)&addr)[2], \
    ((unsigned char *)&addr)[3]
#define NIPQUAD_FMT "%u.%u.%u.%u"

static void dump_eth_header(struct ethhdr *ehdr)
{
    printk(KERN_INFO "ETH src=%02x:%02x:%02x:%02x:%02x:%02x "
                     "dst=%02x:%02x:%02x:%02x:%02x:%02x proto=0x%04x\n",
           ehdr->h_source[0], ehdr->h_source[1], ehdr->h_source[2],
           ehdr->h_source[3], ehdr->h_source[4], ehdr->h_source[5],
           ehdr->h_dest[0],   ehdr->h_dest[1],   ehdr->h_dest[2],
           ehdr->h_dest[3],   ehdr->h_dest[4],   ehdr->h_dest[5],
           ntohs(ehdr->h_proto));
}

static unsigned int nf_log_in_hook(
    unsigned int hook,
    struct sk_buff *skb,
    const struct net_device *in,
    const struct net_device *out,
    int (*okfn)(struct sk_buff *))
{
    struct ethhdr *eth_hdr;
    struct iphdr  *ip_hdr;

    if (!skb)
        return NF_ACCEPT;

    eth_hdr = (struct ethhdr *)skb_mac_header(skb);
    ip_hdr  = (struct iphdr  *)skb_network_header(skb);

    dump_eth_header(eth_hdr);
    printk(KERN_INFO "IP src=" NIPQUAD_FMT " dst=" NIPQUAD_FMT "\n",
           NIPQUAD(ip_hdr->saddr), NIPQUAD(ip_hdr->daddr));

    return NF_ACCEPT;
}

static struct nf_hook_ops nf_log_ops[] __read_mostly = {
    {
        .hook     = nf_log_in_hook,
        .owner    = THIS_MODULE,
        .pf       = NFPROTO_IPV4,
        .hooknum  = NF_INET_LOCAL_IN,
        .priority = NF_IP_PRI_FIRST,
    },
};

static int __init nf_log_init(void)
{
    int ret = nf_register_hooks(nf_log_ops, ARRAY_SIZE(nf_log_ops));
    if (ret < 0) {
        printk(KERN_ERR "nf_log: failed to register hooks: %d\n", ret);
        return ret;
    }
    printk(KERN_NOTICE "nf_log: hook registered at NF_INET_LOCAL_IN\n");
    return 0;
}

static void __exit nf_log_exit(void)
{
    nf_unregister_hooks(nf_log_ops, ARRAY_SIZE(nf_log_ops));
    printk(KERN_NOTICE "nf_log: hook unregistered\n");
}

module_init(nf_log_init);
module_exit(nf_log_exit);
```

### Building and loading the module

Create a minimal `Makefile` in the same directory:

```makefile
obj-m += nf_log.o

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

Then build, load, and watch the output:

```bash
make
sudo insmod nf_log.ko
sudo dmesg -w          # watch kernel log output
# ... generate some traffic ...
sudo rmmod nf_log
```

---

## References

1. [Netfilter — dreamrunner.org](https://wiki.dreamrunner.org/public_html/Linux/Networks/netfilter.html)
2. [Netfilter Architecture — netfilter.org](https://www.netfilter.org/documentation/index.html)
3. `linux/netfilter.h`, `linux/netfilter_ipv4.h` — kernel header files